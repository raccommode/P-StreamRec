<!doctype html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Mod√®le - P-StreamRec</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    
    :root {
      --bg-primary: #0a0e27;
      --bg-secondary: #111432;
      --bg-card: #1a1f3a;
      --bg-card-hover: #232a4a;
      --text-primary: #ffffff;
      --text-secondary: #a0aec0;
      --accent: #6366f1;
      --accent-hover: #4f46e5;
      --success: #10b981;
      --danger: #ef4444;
      --border: rgba(255, 255, 255, 0.1);
      --shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
    }
    
    body {
      font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
      background: linear-gradient(135deg, var(--bg-primary) 0%, #0d1128 100%);
      color: var(--text-primary);
      min-height: 100vh;
      line-height: 1.6;
    }
    
    /* Header */
    .header {
      background: rgba(17, 20, 50, 0.8);
      backdrop-filter: blur(10px);
      border-bottom: 1px solid var(--border);
      padding: 1.5rem 2rem;
      position: sticky;
      top: 0;
      z-index: 100;
      display: flex;
      align-items: center;
      gap: 1rem;
    }
    
    .back-btn {
      width: 40px;
      height: 40px;
      border-radius: 10px;
      background: var(--bg-card);
      border: 1px solid var(--border);
      color: var(--text-primary);
      font-size: 20px;
      cursor: pointer;
      transition: all 0.3s;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    
    .back-btn:hover {
      background: var(--bg-card-hover);
      border-color: var(--accent);
    }
    
    .model-header {
      flex: 1;
    }
    
    .model-title {
      font-size: 1.5rem;
      font-weight: 700;
      background: linear-gradient(135deg, #6366f1 0%, #a855f7 100%);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }
    
    .model-subtitle {
      font-size: 0.9rem;
      color: var(--text-secondary);
      display: flex;
      align-items: center;
      gap: 0.5rem;
      margin-top: 0.25rem;
    }
    
    .status-dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      animation: pulse 2s infinite;
    }
    
    .status-dot.online { background: var(--success); }
    .status-dot.offline { background: #6b7280; animation: none; }
    .status-dot.recording { background: var(--danger); }
    
    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.5; }
    }
    
    .action-btn {
      padding: 0.75rem 1.5rem;
      border-radius: 10px;
      border: none;
      font-size: 1rem;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.3s;
    }
    
    .btn-record {
      background: linear-gradient(135deg, var(--danger) 0%, #dc2626 100%);
      color: white;
    }
    
    .btn-record:hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 20px rgba(239, 68, 68, 0.4);
    }
    
    .btn-stop {
      background: var(--bg-card);
      color: var(--text-secondary);
      border: 1px solid var(--border);
    }
    
    .btn-stop:hover {
      background: var(--bg-card-hover);
    }
    
    .btn-delete {
      background: transparent;
      color: var(--danger);
      border: 1px solid var(--danger);
    }
    
    .btn-delete:hover {
      background: var(--danger);
      color: white;
    }
    
    /* Container */
    .container {
      padding: 1rem;
    }
    
    /* Video Player */
    .player-container {
      position: relative;
      width: 100%;
      background: var(--bg-card);
      border-radius: 16px;
      overflow: hidden;
      margin-bottom: 1.5rem;
      border: 1px solid var(--border);
      min-height: 400px;
    }
    
    .video-player {
      width: 100%;
      max-height: 70vh;
      background: black;
      display: block;
    }
    
    .player-container .empty-message {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      background: var(--bg-card);
      pointer-events: none;
      transition: opacity 0.3s ease;
      z-index: 1;
    }
    
    .player-container.has-video .empty-message {
      opacity: 0;
      pointer-events: none;
    }
    
    .quality-selector {
      position: absolute;
      top: 1rem;
      right: 1rem;
      background: rgba(0, 0, 0, 0.8);
      padding: 0.5rem 1rem;
      border-radius: 8px;
      z-index: 10;
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }
    
    .quality-selector label {
      color: white;
      font-size: 0.9rem;
      font-weight: 600;
    }
    
    .quality-selector select {
      background: var(--bg-secondary);
      color: var(--text-primary);
      border: 1px solid var(--border);
      border-radius: 6px;
      padding: 0.4rem 0.8rem;
      font-size: 0.9rem;
      cursor: pointer;
      outline: none;
      transition: all 0.3s ease;
    }
    
    .quality-selector select:hover {
      background: var(--bg-card-hover);
      border-color: var(--accent);
    }
    
    .quality-selector select:focus {
      border-color: var(--accent);
      box-shadow: 0 0 0 2px rgba(99, 102, 241, 0.2);
    }
    
    .control-btn {
      padding: 0.5rem 1rem;
      border-radius: 8px;
      border: none;
      background: var(--bg-secondary);
      color: var(--text-secondary);
      cursor: pointer;
      transition: all 0.3s;
      font-size: 0.9rem;
    }
    .control-btn:hover {
      background: var(--bg-card-hover);
      color: var(--text-primary);
    }
    
    /* Onglets */
    .tabs {
      display: flex;
      gap: 0.5rem;
      margin-bottom: 1.5rem;
      border-bottom: 2px solid var(--border);
    }
    
    .tab-btn {
      background: none;
      border: none;
      color: var(--text-secondary);
      padding: 1rem 1.5rem;
      font-size: 1rem;
      font-weight: 600;
      cursor: pointer;
      border-bottom: 3px solid transparent;
      transition: all 0.3s ease;
    }
    
    .tab-btn:hover {
      color: var(--text-primary);
      background: rgba(255, 255, 255, 0.05);
    }
    
    .tab-btn.active {
      color: var(--accent);
      border-bottom-color: var(--accent);
    }
    
    .tab-content {
      display: none;
    }
    
    .tab-content.active {
      display: block;
    }
    
    /* Recordings */
    .recordings-section {
      background: var(--bg-card);
      border-radius: 16px;
      padding: 1.5rem;
      border: 1px solid var(--border);
    }
    
    .section-header {
      font-size: 1.25rem;
      font-weight: 600;
      margin-bottom: 1rem;
      display: flex;
      align-items: center;
      justify-content: space-between;
    }
    
    .recordings-list {
      display: grid;
      gap: 0.75rem;
    }
    
    .recording-item {
      display: flex;
      align-items: center;
      gap: 1rem;
      padding: 1rem;
      background: var(--bg-secondary);
      border-radius: 12px;
      border: 1px solid var(--border);
      transition: all 0.3s ease;
    }
    
    .recording-item:hover {
      background: var(--bg-card-hover);
      border-color: var(--accent);
      transform: translateY(-2px);
    }
    
    .recording-thumbnail {
      width: 160px;
      height: 90px;
      object-fit: cover;
      border-radius: 8px;
      cursor: pointer;
      transition: all 0.3s ease;
    }
    
    .recording-thumbnail:hover {
      transform: scale(1.05);
      box-shadow: 0 4px 12px rgba(99, 102, 241, 0.3);
    }
    
    .recording-info {
      flex: 1;
      cursor: pointer;
    }
    
    .recording-title {
      font-size: 1rem;
      font-weight: 600;
      color: var(--text-primary);
      margin-bottom: 0.25rem;
    }
    
    .recording-meta {
      font-size: 0.85rem;
      color: var(--text-secondary);
      margin-bottom: 0.5rem;
    }
    
    .watch-progress {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      margin-top: 0.5rem;
    }
    
    .progress-bar {
      flex: 1;
      height: 4px;
      background: var(--bg-primary);
      border-radius: 2px;
      overflow: hidden;
    }
    
    .progress-fill {
      height: 100%;
      background: var(--accent);
      border-radius: 2px;
      transition: width 0.3s ease;
    }
    
    .progress-text {
      font-size: 0.75rem;
      color: var(--text-secondary);
      min-width: 100px;
      text-align: right;
      white-space: nowrap;
    }
    
    .recording-actions {
      display: flex;
      gap: 0.5rem;
    }
    
    .play-btn {
      background: var(--accent);
      color: white;
      border: none;
      width: 40px;
      height: 40px;
      border-radius: 50%;
      font-size: 1.2rem;
      cursor: pointer;
      transition: all 0.3s ease;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    
    .play-btn:hover {
      background: var(--accent-hover);
      transform: scale(1.1);
    }
    
    .delete-btn {
      background: var(--danger);
      color: white;
      border: none;
      width: 40px;
      height: 40px;
      border-radius: 50%;
      font-size: 1.1rem;
      cursor: pointer;
      transition: all 0.3s ease;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    
    .delete-btn:hover {
      background: #dc2626;
      transform: scale(1.1);
    }
    
    .recording-name {
      font-weight: 600;
      margin-bottom: 0.25rem;
    }
    
    .recording-meta {
      font-size: 0.85rem;
      color: var(--text-secondary);
    }
    
    .recording-actions {
      display: flex;
      gap: 0.5rem;
    }
    
    .icon-btn {
      width: 36px;
      height: 36px;
      border-radius: 8px;
      border: none;
      background: var(--bg-card);
      color: var(--text-secondary);
      cursor: pointer;
      transition: all 0.3s;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 1.1rem;
    }
    
    .icon-btn:hover {
      background: var(--accent);
      color: white;
    }
    
    .empty-message {
      text-align: center;
      padding: 3rem 1rem;
      color: var(--text-secondary);
    }
    
    .empty-message .icon {
      font-size: 3rem;
      margin-bottom: 1rem;
      opacity: 0.5;
    }
  </style>
  <script defer src="https://cdn.jsdelivr.net/npm/hls.js@1"></script>
</head>
<body>
  <header class="header">
    <button class="back-btn" onclick="window.location.href='/'">‚Üê</button>
    <div class="model-header">
      <div class="model-title" id="modelName">Chargement...</div>
      <div class="model-subtitle">
        <span class="status-dot" id="statusDot"></span>
        <span id="statusText">V√©rification...</span>
      </div>
    </div>
    <button class="action-btn btn-record" id="recordBtn" onclick="toggleRecording()">
      ‚è∫ D√©marrer l'enregistrement
    </button>
    <button class="action-btn btn-delete" onclick="deleteModel()">
    </button>
  </header>

  <div class="container">
    <!-- Onglets -->
    <div class="tabs">
      <button class="tab-btn active" onclick="switchTab('live')">üì∫ Live</button>
      <button class="tab-btn" onclick="switchTab('recordings')">üìÅ Rediffusions</button>
    </div>

    <!-- Contenu Live -->
    <div id="tab-live" class="tab-content active">
      <div class="player-container">
        <video id="player" class="video-player" controls muted autoplay></video>
        <div class="quality-selector" id="qualitySelector" style="display: none;">
          <label for="qualitySelect">Qualit√© :</label>
          <select id="qualitySelect" onchange="changeQuality(this.value)">
            <option value="-1">üéØ Meilleure</option>
          </select>
        </div>
        <div class="empty-message">
          <div class="icon">üì∫</div>
          <p>Aucun stream en cours</p>
        </div>
      </div>
    </div>

    <!-- Contenu Rediffusions -->
    <div id="tab-recordings" class="tab-content">
      <div class="recordings-section">
        <div class="section-header">
          <span>üìÅ Enregistrements disponibles</span>
          <span class="recording-meta" id="recordingsCount">0 fichier</span>
        </div>
        <div class="recordings-list" id="recordingsList">
          <!-- Les enregistrements seront ajout√©s ici -->
        </div>
      </div>
    </div>
  </div>

  <script>
    const urlParams = new URLSearchParams(window.location.search);
    const username = urlParams.get('username');
    let currentSession = null;
    let hlsPlayer = null;

    if (!username) {
      window.location.href = '/';
    }

    // Initialisation
    document.getElementById('modelName').textContent = username;

    // R√©cup√©rer l'√©tat du mod√®le
    async function updateModelStatus() {
      try {
        // R√©cup√©rer les sessions actives
        const res = await fetch('/api/status');
        const sessions = await res.json();
        const session = sessions.find(s => s.person === username);

        // R√©cup√©rer le statut en ligne
        const statusRes = await fetch(`/api/model/${username}/status`);
        const modelInfo = statusRes.ok ? await statusRes.json() : { isOnline: false };

        if (session && session.running) {
          const wasRecording = currentSession && currentSession.id === session.id;
          currentSession = session;
          
          console.log('üìä Session trouv√©e:', session);
          console.log('üì∫ Playback URL:', session.playback_url);
          console.log('üîÑ √âtait d√©j√† en enregistrement:', wasRecording);
          
          document.getElementById('statusDot').className = 'status-dot recording';
          document.getElementById('statusText').textContent = 'En enregistrement';
          document.getElementById('recordBtn').innerHTML = '‚èπÔ∏è Arr√™ter l\'enregistrement';
          document.getElementById('recordBtn').className = 'action-btn btn-stop';
          
          // Charger le stream UNIQUEMENT si ce n'√©tait pas d√©j√† en cours
          if (!wasRecording) {
            console.log('‚ñ∂Ô∏è Chargement du stream...');
            loadStream(session.playback_url);
          } else {
            console.log('‚è≠Ô∏è Stream d√©j√† charg√©, skip');
          }
        } else if (modelInfo.isOnline) {
          currentSession = null;
          document.getElementById('statusDot').className = 'status-dot online';
          document.getElementById('statusText').textContent = 'En ligne';
          document.getElementById('recordBtn').innerHTML = '‚è∫ D√©marrer l\'enregistrement';
          document.getElementById('recordBtn').className = 'action-btn btn-record';
        } else {
          currentSession = null;
          document.getElementById('statusDot').className = 'status-dot offline';
          document.getElementById('statusText').textContent = 'Hors ligne';
          document.getElementById('recordBtn').innerHTML = '‚è∫ D√©marrer l\'enregistrement';
          document.getElementById('recordBtn').className = 'action-btn btn-record';
        }
      } catch (e) {
        console.error('Erreur statut:', e);
      }
    }

    // Toggle enregistrement
    async function toggleRecording() {
      if (currentSession) {
        // Arr√™ter
        try {
          const res = await fetch(`/api/stop/${currentSession.id}`, { method: 'POST' });
          if (res.ok) {
            showNotification('Enregistrement arr√™t√©');
            updateModelStatus();
          }
        } catch (e) {
          showNotification('Erreur lors de l\'arr√™t', 'error');
        }
      } else {
        // D√©marrer
        try {
          const res = await fetch('/api/start', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              target: username,
              source_type: 'chaturbate',
              person: username,
              name: username
            })
          });
          
          if (res.ok) {
            const data = await res.json();
            showNotification('Enregistrement d√©marr√©!');
            updateModelStatus();
          } else if (res.status === 409) {
            // Session d√©j√† en cours, charger le stream quand m√™me
            console.log('‚è≠Ô∏è Session d√©j√† en cours, chargement du stream...');
            await updateModelStatus();
          } else {
            const error = await res.json();
            showNotification(error.detail || 'Erreur', 'error');
          }
        } catch (e) {
          showNotification('Erreur lors du d√©marrage', 'error');
        }
      }
    }

    // Charger le stream avec retry si le manifest n'est pas encore pr√™t
    async function loadStream(url) {
      console.log('üé¨ Chargement du stream:', url);
      const video = document.getElementById('player');
      
      // Attendre que le manifest soit disponible (max 10 tentatives)
      let retries = 10;
      while (retries > 0) {
        try {
          const checkResponse = await fetch(url, { method: 'HEAD' });
          if (checkResponse.ok) {
            console.log('‚úÖ Manifest disponible');
            break;
          }
        } catch (e) {
          console.log(`‚è≥ Manifest pas encore disponible, attente... (${retries} tentatives restantes)`);
        }
        retries--;
        if (retries > 0) {
          await new Promise(resolve => setTimeout(resolve, 1000)); // Attendre 1 seconde
        }
      }
      
      if (retries === 0) {
        console.error('‚ùå Manifest toujours indisponible apr√®s 10 secondes');
        showNotification('Stream non disponible, r√©essayez dans quelques secondes', 'error');
        return;
      }
      
      // Marquer le conteneur comme ayant une vid√©o
      const playerContainer = document.querySelector('.player-container');
      if (playerContainer) {
        playerContainer.classList.add('has-video');
      }
      
      if (video.canPlayType('application/vnd.apple.mpegurl')) {
        console.log('üì± Utilisation du lecteur natif');
        video.src = url;
        video.muted = true; // Son coup√©
        // D√©marrer automatiquement
        video.play().catch(e => {
          console.log('Autoplay bloqu√©');
          showNotification('Cliquez sur ‚ñ∂Ô∏è pour lancer', 'info');
        });
      } else if (window.Hls && window.Hls.isSupported()) {
        console.log('üé• Utilisation de HLS.js');
        if (hlsPlayer) {
          hlsPlayer.destroy();
        }
        hlsPlayer = new Hls({ 
          debug: false,
          enableWorker: false,
          capLevelToPlayerSize: false,  // Ne pas limiter la qualit√© √† la taille du lecteur
        });
        
        // Gestion des erreurs HLS
        hlsPlayer.on(Hls.Events.ERROR, (event, data) => {
          console.error('‚ùå Erreur HLS:', data);
          console.error('Type:', data.type, 'Fatal:', data.fatal, 'Details:', data.details);
          
          // Afficher l'erreur √† l'utilisateur
          const errorMsg = `Erreur HLS: ${data.details} (${data.type})`;
          showNotification(errorMsg, 'error');
          
          if (data.fatal) {
            switch(data.type) {
              case Hls.ErrorTypes.NETWORK_ERROR:
                console.log('üîÑ Erreur r√©seau, tentative de r√©cup√©ration...');
                showNotification('Erreur r√©seau, reconnexion...', 'info');
                hlsPlayer.startLoad();
                break;
              case Hls.ErrorTypes.MEDIA_ERROR:
                console.log('üîÑ Erreur m√©dia, tentative de r√©cup√©ration...');
                showNotification('Erreur m√©dia, r√©cup√©ration...', 'info');
                hlsPlayer.recoverMediaError();
                break;
              default:
                console.error('üí• Erreur fatale, rechargement...');
                showNotification('Erreur fatale, rechargement dans 2s...', 'error');
                hlsPlayer.destroy();
                setTimeout(() => loadStream(url), 2000);
                break;
            }
          }
        });
        
        hlsPlayer.loadSource(url);
        hlsPlayer.attachMedia(video);
        
        hlsPlayer.on(Hls.Events.MANIFEST_PARSED, () => {
          console.log('‚úÖ Manifest charg√©, d√©marrage lecture...');
          
          // FORCER LA MEILLEURE QUALIT√â
          if (hlsPlayer.levels.length > 0) {
            const highestLevel = hlsPlayer.levels.length - 1;
            hlsPlayer.loadLevel = highestLevel;  // Forcer le niveau le plus √©lev√©
            hlsPlayer.autoLevelCapping = highestLevel;  // Limiter le plafond auto au max
            console.log(`üéöÔ∏è Meilleure qualit√© forc√©e: ${hlsPlayer.levels[highestLevel].height}p`);
          }
          
          // Afficher le s√©lecteur de qualit√© si plusieurs niveaux disponibles
          if (hlsPlayer.levels.length > 1) {
            updateQualitySelector();
          }
          
          // Son coup√© pour autoplay
          video.muted = true;
          // D√©marrer automatiquement
          video.play().then(() => {
            console.log('‚úÖ Lecture d√©marr√©e (son coup√©)');
            showNotification('Lecture d√©marr√©e (cliquez üîä pour activer le son)', 'info');
          }).catch(e => {
            console.log('Autoplay bloqu√©');
            showNotification('Cliquez sur ‚ñ∂Ô∏è pour lancer', 'info');
          });
        });
        
        hlsPlayer.on(Hls.Events.LEVEL_LOADED, (event, data) => {
          console.log('‚úÖ Niveau charg√©:', data.level, 'Segments:', data.details.fragments.length);
        });
        
        hlsPlayer.on(Hls.Events.LEVEL_SWITCHED, (event, data) => {
          console.log('üéöÔ∏è Qualit√© chang√©e:', data.level);
          updateQualitySelector();
        });
        
      } else {
        console.error('HLS non support√© par ce navigateur');
        showNotification('HLS non support√©', 'error');
      }
    }

    // Mettre √† jour le s√©lecteur de qualit√©
    function updateQualitySelector() {
      if (!hlsPlayer || hlsPlayer.levels.length <= 1) {
        document.getElementById('qualitySelector').style.display = 'none';
        return;
      }
      
      const selector = document.getElementById('qualitySelector');
      const select = document.getElementById('qualitySelect');
      
      // Vider les options
      select.innerHTML = '<option value="-1">üéØ Meilleure</option>';
      
      // Ajouter toutes les qualit√©s disponibles
      hlsPlayer.levels.forEach((level, index) => {
        const height = level.height;
        const bitrate = Math.round(level.bitrate / 1000);
        const label = height ? `${height}p (${bitrate} kbps)` : `${bitrate} kbps`;
        
        const option = document.createElement('option');
        option.value = index;
        option.textContent = label;
        
        if (hlsPlayer.currentLevel === index) {
          option.selected = true;
        }
        
        select.appendChild(option);
      });
      
      // Afficher le s√©lecteur
      selector.style.display = 'flex';
      
      console.log(`üéöÔ∏è ${hlsPlayer.levels.length} qualit√©s disponibles`);
    }
    
    // Changer la qualit√©
    function changeQuality(levelIndex) {
      if (!hlsPlayer) return;
      
      const level = parseInt(levelIndex);
      
      if (level === -1) {
        // Mode Auto = Forcer la meilleure qualit√© disponible
        const highestLevel = hlsPlayer.levels.length - 1;
        hlsPlayer.loadLevel = highestLevel;
        hlsPlayer.autoLevelCapping = highestLevel;
        const bestLevel = hlsPlayer.levels[highestLevel];
        const label = bestLevel.height ? `${bestLevel.height}p` : `${Math.round(bestLevel.bitrate / 1000)} kbps`;
        console.log(`üéöÔ∏è Mode Auto: Meilleure qualit√© forc√©e (${label})`);
        showNotification(`Qualit√©: Meilleure (${label})`, 'info');
      } else {
        hlsPlayer.currentLevel = level;
        const selectedLevel = hlsPlayer.levels[level];
        const label = selectedLevel.height ? `${selectedLevel.height}p` : `${Math.round(selectedLevel.bitrate / 1000)} kbps`;
        console.log(`üéöÔ∏è Qualit√© s√©lectionn√©e: ${label}`);
        showNotification(`Qualit√©: ${label}`, 'info');
      }
    }

    // Charger les enregistrements
    async function loadRecordings() {
      const list = document.getElementById('recordingsList');
      const count = document.getElementById('recordingsCount');
      
      try {
        const res = await fetch(`/api/recordings/${username}`);
        const data = await res.json();
        
        // Filtrer les enregistrements: NE PAS afficher celui en cours (aujourd'hui)
        const today = new Date().toISOString().split('T')[0]; // Format YYYY-MM-DD
        const recordings = (data.recordings || []).filter(rec => {
          // Si un enregistrement est en cours pour aujourd'hui, on ne l'affiche pas
          if (currentSession && currentSession.running && rec.date === today) {
            return false;
          }
          return true;
        });
        
        if (recordings.length > 0) {
          count.textContent = `${recordings.length} fichier${recordings.length > 1 ? 's' : ''}`;
          
          list.innerHTML = recordings.map(rec => {
            const progress = getWatchProgress(rec.filename);
            const progressPercent = progress ? Math.round((progress.position / progress.duration) * 100) : 0;
            
            // Formater le temps de progression
            let progressTimeStr = '';
            if (progress && progress.position > 0) {
              const pos = Math.floor(progress.position);
              const dur = Math.floor(progress.duration);
              
              const formatTime = (seconds) => {
                const h = Math.floor(seconds / 3600);
                const m = Math.floor((seconds % 3600) / 60);
                const s = seconds % 60;
                if (h > 0) return `${h}h${m.toString().padStart(2, '0')}m`;
                return `${m}m${s.toString().padStart(2, '0')}s`;
              };
              
              progressTimeStr = `${formatTime(pos)} / ${formatTime(dur)}`;
            }
            
            return `
            <div class="recording-item">
              <img 
                src="${rec.thumbnail || '/api/recording-thumbnail/' + username + '/' + rec.date + '.jpg'}" 
                alt="${rec.date}"
                class="recording-thumbnail"
                onerror="this.src='data:image/svg+xml,%3Csvg xmlns=%22http://www.w3.org/2000/svg%22 width=%22160%22 height=%2290%22%3E%3Crect fill=%22%231a1f3a%22 width=%22160%22 height=%2290%22/%3E%3Ctext x=%2250%25%22 y=%2250%25%22 dominant-baseline=%22middle%22 text-anchor=%22middle%22 fill=%22%23a0aec0%22 font-size=%2214%22%3Eüìπ%3C/text%3E%3C/svg%3E'"
                onclick="playRecording('${rec.url}', '${rec.filename}')"
              />
              <div class="recording-info" onclick="playRecording('${rec.url}', '${rec.filename}')">
                <div class="recording-title">üìπ ${rec.date}</div>
                <div class="recording-meta">
                  ${rec.duration_str || ''} ${rec.duration_str ? '¬∑' : ''} ${rec.size_mb} MB
                </div>
                ${progressPercent > 0 ? `
                  <div class="watch-progress">
                    <div class="progress-bar">
                      <div class="progress-fill" style="width: ${progressPercent}%"></div>
                    </div>
                    <span class="progress-text">${progressTimeStr}</span>
                  </div>
                ` : ''}
              </div>
              <div class="recording-actions">
                <button class="play-btn" onclick="event.stopPropagation(); playRecording('${rec.url}', '${rec.filename}')">‚ñ∂Ô∏è</button>
                <button class="delete-btn" onclick="event.stopPropagation(); deleteRecording('${rec.filename}')">üóëÔ∏è</button>
              </div>
            </div>
          `;
          }).join('');
        } else {
          list.innerHTML = `
            <div class="empty-message">
              <div class="icon">üìÇ</div>
              <p>Aucun enregistrement disponible</p>
              <p style="font-size: 0.85rem; margin-top: 0.5rem; opacity: 0.7;">Les enregistrements appara√Ætront ici</p>
            </div>
          `;
          count.textContent = '0 fichier';
        }
      } catch (e) {
        console.error('Erreur chargement enregistrements:', e);
        list.innerHTML = `
          <div class="empty-message">
            <div class="icon">‚ö†Ô∏è</div>
            <p>Erreur de chargement</p>
          </div>
        `;
      }
    }
    
    // Sauvegarder la progression de lecture
    function saveWatchProgress(filename, position, duration) {
      const key = `watch_progress_${username}_${filename}`;
      localStorage.setItem(key, JSON.stringify({ position, duration, timestamp: Date.now() }));
    }
    
    // R√©cup√©rer la progression de lecture
    function getWatchProgress(filename) {
      const key = `watch_progress_${username}_${filename}`;
      const data = localStorage.getItem(key);
      return data ? JSON.parse(data) : null;
    }
    
    // Variable pour suivre l'enregistrement en cours
    let currentRecordingFile = null;
    
    // Lire un enregistrement
    function playRecording(url, filename) {
      console.log('üìπ Lecture enregistrement:', url);
      
      // S√âCURIT√â: Emp√™cher la lecture de l'enregistrement du jour en cours
      const today = new Date().toISOString().split('T')[0];
      const recordingDate = filename.replace('.ts', '');
      
      if (currentSession && currentSession.running && recordingDate === today) {
        showNotification('‚ö†Ô∏è Enregistrement en cours ! Regardez le live au lieu de la rediffusion.', 'error');
        switchTab('live');
        return;
      }
      
      const video = document.getElementById('player');
      const container = document.querySelector('.player-container');
      
      // Arr√™ter le lecteur HLS si actif
      if (hlsPlayer) {
        hlsPlayer.destroy();
        hlsPlayer = null;
      }
      
      // Masquer le s√©lecteur de qualit√© (pas de HLS pour les rediffusions)
      document.getElementById('qualitySelector').style.display = 'none';
      
      currentRecordingFile = filename;
      
      // Afficher le conteneur vid√©o
      container.classList.add('has-video');
      
      // Charger la vid√©o directement
      video.src = url;
      video.load();  // Force le chargement
      
      // Reprendre √† la position sauvegard√©e
      const progress = getWatchProgress(filename);
      if (progress && progress.position > 10) {
        video.addEventListener('loadedmetadata', () => {
          video.currentTime = progress.position;
          showNotification(`Reprise √† ${Math.floor(progress.position / 60)}min ${Math.floor(progress.position % 60)}s`, 'info');
        }, { once: true });
      }
      
      // D√©marrer la lecture
      video.play().catch(e => {
        console.error('Erreur lecture:', e);
        showNotification('Cliquez sur ‚ñ∂Ô∏è pour lancer la lecture', 'info');
      });
      
      // Retourner √† l'onglet Live pour voir le lecteur
      switchTab('live');
      
      showNotification('Chargement de la rediffusion...', 'info');
    }
    
    // Supprimer un enregistrement
    async function deleteRecording(filename) {
      if (!confirm(`Supprimer ${filename.replace('.ts', '')} ?\n\nCette action est irr√©versible.`)) {
        return;
      }
      
      try {
        const res = await fetch(`/api/recordings/${username}/${filename}`, {
          method: 'DELETE'
        });
        
        if (res.ok) {
          showNotification('Enregistrement supprim√©', 'info');
          // Supprimer aussi la progression
          const key = `watch_progress_${username}_${filename}`;
          localStorage.removeItem(key);
          // Recharger la liste
          loadRecordings();
        } else {
          showNotification('Erreur lors de la suppression', 'error');
        }
      } catch (e) {
        console.error('Erreur suppression:', e);
        showNotification('Erreur lors de la suppression', 'error');
      }
    }

    // Switch entre onglets
    function switchTab(tabName) {
      // G√©rer les boutons
      document.querySelectorAll('.tab-btn').forEach(btn => btn.classList.remove('active'));
      event.target.classList.add('active');
      
      // G√©rer le contenu
      document.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));
      document.getElementById(`tab-${tabName}`).classList.add('active');
      
      // Si onglet recordings, charger la liste
      if (tabName === 'recordings') {
        loadRecordings();
      }
    }

    // Supprimer le mod√®le
    async function deleteModel() {
      if (!confirm(`Voulez-vous vraiment supprimer ${username} de votre liste ?`)) {
        return;
      }
      
      try {
        const res = await fetch(`/api/models/${username}`, {
          method: 'DELETE'
        });
        
        if (res.ok) {
          showNotification('Mod√®le supprim√©');
          setTimeout(() => window.location.href = '/', 1000);
        } else {
          showNotification('Erreur lors de la suppression', 'error');
        }
      } catch (e) {
        console.error('Erreur suppression mod√®le:', e);
        showNotification('Erreur de connexion', 'error');
      }
    }

    // Notification
    function showNotification(message, type = 'success') {
      const notif = document.createElement('div');
      const bgColor = type === 'success' ? '#10b981' : '#ef4444';
      notif.style.cssText = `
        position: fixed;
        top: 20px;
        right: 20px;
        background: ${bgColor};
        color: white;
        padding: 1rem 1.5rem;
        border-radius: 10px;
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
        z-index: 9999;
        font-weight: 500;
      `;
      notif.textContent = message;
      document.body.appendChild(notif);
      setTimeout(() => notif.remove(), 3000);
    }

    // D√©marrage automatique de l'enregistrement si en ligne
    async function autoStartRecording() {
      try {
        const statusRes = await fetch(`/api/model/${username}/status`);
        if (!statusRes.ok) return;
        
        const modelInfo = await statusRes.json();
        
        // Si le mod√®le est en ligne
        if (modelInfo.isOnline) {
          // V√©rifier s'il n'y a pas d√©j√† une session
          const sessionsRes = await fetch('/api/status');
          const sessions = await sessionsRes.json();
          const existingSession = sessions.find(s => s.person === username && s.running);
          
          // Si pas de session, d√©marrer automatiquement
          if (!existingSession) {
            console.log(`üé¨ D√©marrage automatique de l'enregistrement pour ${username}`);
            await toggleRecording();
          } else {
            console.log(`‚è≠Ô∏è Session d√©j√† en cours pour ${username}, chargement du stream...`);
            // La session existe d√©j√†, on va juste charger le stream
            await updateModelStatus();
          }
        }
      } catch (e) {
        console.error('Erreur auto-start:', e);
      }
    }

    // Sauvegarder la progression toutes les 10 secondes
    const video = document.getElementById('player');
    setInterval(() => {
      if (currentRecordingFile && video.currentTime > 0 && video.duration > 0) {
        saveWatchProgress(currentRecordingFile, video.currentTime, video.duration);
      }
    }, 10000);
    
    // Sauvegarder aussi √† la pause ou en quittant la page
    video.addEventListener('pause', () => {
      if (currentRecordingFile && video.currentTime > 0 && video.duration > 0) {
        saveWatchProgress(currentRecordingFile, video.currentTime, video.duration);
      }
    });
    
    window.addEventListener('beforeunload', () => {
      if (currentRecordingFile && video.currentTime > 0 && video.duration > 0) {
        saveWatchProgress(currentRecordingFile, video.currentTime, video.duration);
      }
    });

    // Initialisation
    updateModelStatus();
    loadRecordings();
    
    // D√©marrer automatiquement l'enregistrement apr√®s un court d√©lai
    setTimeout(autoStartRecording, 2000);
    
    // Rafra√Æchir toutes les 10 secondes (moins agressif)
    setInterval(updateModelStatus, 10000);
  </script>
</body>
</html>
