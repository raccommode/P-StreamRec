<!doctype html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Mod√®le - P-StreamRec</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    
    :root {
      --bg-primary: #0a0e27;
      --bg-secondary: #111432;
      --bg-card: #1a1f3a;
      --bg-card-hover: #232a4a;
      --text-primary: #ffffff;
      --text-secondary: #a0aec0;
      --accent: #6366f1;
      --accent-hover: #4f46e5;
      --success: #10b981;
      --danger: #ef4444;
      --border: rgba(255, 255, 255, 0.1);
      --shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
    }
    
    body {
      font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
      background: linear-gradient(135deg, var(--bg-primary) 0%, #0d1128 100%);
      color: var(--text-primary);
      min-height: 100vh;
      line-height: 1.6;
    }
    
    /* Header */
    .header {
      background: rgba(17, 20, 50, 0.8);
      backdrop-filter: blur(10px);
      border-bottom: 1px solid var(--border);
      padding: 1.5rem 2rem;
      position: sticky;
      top: 0;
      z-index: 100;
      display: flex;
      align-items: center;
      gap: 1rem;
    }
    
    .back-btn {
      width: 40px;
      height: 40px;
      border-radius: 10px;
      background: var(--bg-card);
      border: 1px solid var(--border);
      color: var(--text-primary);
      font-size: 20px;
      cursor: pointer;
      transition: all 0.3s;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    
    .back-btn:hover {
      background: var(--bg-card-hover);
      border-color: var(--accent);
    }
    
    .model-header {
      flex: 1;
    }
    
    .model-title {
      font-size: 1.5rem;
      font-weight: 700;
      background: linear-gradient(135deg, #6366f1 0%, #a855f7 100%);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }
    
    .model-subtitle {
      font-size: 0.9rem;
      color: var(--text-secondary);
      display: flex;
      align-items: center;
      gap: 0.5rem;
      margin-top: 0.25rem;
    }
    
    .status-dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      animation: pulse 2s infinite;
    }
    
    .status-dot.online { background: var(--success); }
    .status-dot.offline { background: #6b7280; animation: none; }
    .status-dot.recording { background: var(--danger); }
    
    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.5; }
    }
    
    .action-btn {
      padding: 0.75rem 1.5rem;
      border-radius: 10px;
      border: none;
      font-size: 1rem;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.3s;
    }
    
    .btn-record {
      background: linear-gradient(135deg, var(--danger) 0%, #dc2626 100%);
      color: white;
    }
    
    .btn-record:hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 20px rgba(239, 68, 68, 0.4);
    }
    
    .btn-stop {
      background: var(--bg-card);
      color: var(--text-secondary);
      border: 1px solid var(--border);
    }
    
    .btn-stop:hover {
      background: var(--bg-card-hover);
    }
    
    .btn-delete {
      background: transparent;
      color: var(--danger);
      border: 1px solid var(--danger);
    }
    
    .btn-delete:hover {
      background: var(--danger);
      color: white;
    }
    
    /* Container */
    .container {
      padding: 1rem;
    }
    
    /* Video Player */
    .player-container {
      position: relative;
      width: 100%;
      background: var(--bg-card);
      border-radius: 16px;
      overflow: hidden;
      margin-bottom: 1.5rem;
      border: 1px solid var(--border);
      min-height: 400px;
    }
    
    .video-player {
      width: 100%;
      max-height: 70vh;
      background: black;
      display: block;
    }
    
    .player-container .empty-message {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      background: var(--bg-card);
      pointer-events: none;
      transition: opacity 0.3s ease;
      z-index: 1;
    }
    
    .player-container.has-video .empty-message {
      opacity: 0;
      pointer-events: none;
    }
    
    .quality-selector {
      position: absolute;
      top: 1rem;
      right: 1rem;
      background: rgba(0, 0, 0, 0.8);
      padding: 0.5rem 1rem;
      border-radius: 8px;
      z-index: 10;
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }
    
    .quality-selector label {
      color: white;
      font-size: 0.9rem;
      font-weight: 600;
    }
    
    .quality-selector select {
      background: var(--bg-secondary);
      color: var(--text-primary);
      border: 1px solid var(--border);
      border-radius: 6px;
      padding: 0.4rem 0.8rem;
      font-size: 0.9rem;
      cursor: pointer;
      outline: none;
      transition: all 0.3s ease;
    }
    
    .quality-selector select:hover {
      background: var(--bg-card-hover);
      border-color: var(--accent);
    }
    
    .quality-selector select:focus {
      border-color: var(--accent);
      box-shadow: 0 0 0 2px rgba(99, 102, 241, 0.2);
    }
    
    .control-btn {
      padding: 0.5rem 1rem;
      border-radius: 8px;
      border: none;
      background: var(--bg-secondary);
      color: var(--text-secondary);
      cursor: pointer;
      transition: all 0.3s;
      font-size: 0.9rem;
    }
    .control-btn:hover {
      background: var(--bg-card-hover);
      color: var(--text-primary);
    }
    
    /* Onglets */
    .tabs {
      display: flex;
      gap: 0.5rem;
      margin-bottom: 1.5rem;
      border-bottom: 2px solid var(--border);
    }
    
    .tab-btn {
      background: none;
      border: none;
      color: var(--text-secondary);
      padding: 1rem 1.5rem;
      font-size: 1rem;
      font-weight: 600;
      cursor: pointer;
      border-bottom: 3px solid transparent;
      transition: all 0.3s ease;
    }
    
    .tab-btn:hover {
      color: var(--text-primary);
      background: rgba(255, 255, 255, 0.05);
    }
    
    .tab-btn.active {
      color: var(--accent);
      border-bottom-color: var(--accent);
    }
    
    .tab-content {
      display: none;
    }
    
    .tab-content.active {
      display: block;
    }
    
    /* Recordings */
    .recordings-section {
      background: var(--bg-card);
      border-radius: 16px;
      padding: 1.5rem;
      border: 1px solid var(--border);
    }
    
    .section-header {
      font-size: 1.25rem;
      font-weight: 600;
      margin-bottom: 1rem;
      display: flex;
      align-items: center;
      justify-content: space-between;
    }
    
    .recordings-list {
      display: grid;
      gap: 0.75rem;
    }
    
    .recording-item {
      display: flex;
      align-items: center;
      gap: 1rem;
      padding: 1rem;
      background: var(--bg-secondary);
      border-radius: 12px;
      border: 1px solid var(--border);
      transition: all 0.3s ease;
    }
    
    .recording-item:hover {
      background: var(--bg-card-hover);
      border-color: var(--accent);
      transform: translateY(-2px);
    }
    
    .recording-thumbnail {
      width: 160px;
      height: 90px;
      object-fit: cover;
      border-radius: 8px;
      cursor: pointer;
      transition: all 0.3s ease;
    }
    
    .recording-thumbnail:hover {
      transform: scale(1.05);
      box-shadow: 0 4px 12px rgba(99, 102, 241, 0.3);
    }
    
    .recording-info {
      flex: 1;
      cursor: pointer;
    }
    
    .recording-title {
      font-size: 1rem;
      font-weight: 600;
      color: var(--text-primary);
      margin-bottom: 0.25rem;
    }
    
    .recording-meta {
      font-size: 0.85rem;
      color: var(--text-secondary);
      margin-bottom: 0.5rem;
    }
    
    .watch-progress {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      margin-top: 0.5rem;
    }
    
    .progress-bar {
      flex: 1;
      height: 4px;
      background: var(--bg-primary);
      border-radius: 2px;
      overflow: hidden;
    }
    
    .progress-fill {
      height: 100%;
      background: var(--accent);
      border-radius: 2px;
      transition: width 0.3s ease;
    }
    
    .progress-text {
      font-size: 0.75rem;
      color: var(--text-secondary);
      min-width: 100px;
      text-align: right;
      white-space: nowrap;
    }
    
    .recording-actions {
      display: flex;
      gap: 0.5rem;
    }
    
    .play-btn {
      background: var(--accent);
      color: white;
      border: none;
      width: 40px;
      height: 40px;
      border-radius: 50%;
      font-size: 1.2rem;
      cursor: pointer;
      transition: all 0.3s ease;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    
    .play-btn:hover {
      background: var(--accent-hover);
      transform: scale(1.1);
    }
    
    .delete-btn {
      background: var(--danger);
      color: white;
      border: none;
      width: 40px;
      height: 40px;
      border-radius: 50%;
      font-size: 1.1rem;
      cursor: pointer;
      transition: all 0.3s ease;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    
    .delete-btn:hover {
      background: #dc2626;
      transform: scale(1.1);
    }
    
    .recording-name {
      font-weight: 600;
      margin-bottom: 0.25rem;
    }
    
    .recording-meta {
      font-size: 0.85rem;
      color: var(--text-secondary);
    }
    
    .recording-actions {
      display: flex;
      gap: 0.5rem;
    }
    
    .icon-btn {
      width: 36px;
      height: 36px;
      border-radius: 8px;
      border: none;
      background: var(--bg-card);
      color: var(--text-secondary);
      cursor: pointer;
      transition: all 0.3s;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 1.1rem;
    }
    
    .icon-btn:hover {
      background: var(--accent);
      color: white;
    }
    
    .empty-message {
      text-align: center;
      padding: 3rem 1rem;
      color: var(--text-secondary);
    }
    
    .empty-message .icon {
      font-size: 3rem;
      margin-bottom: 1rem;
      opacity: 0.5;
    }
  </style>
  <script defer src="https://cdn.jsdelivr.net/npm/hls.js@1"></script>
  <script>
    // Charger la version depuis l'API (synchronis√©e avec version.json)
    (async function loadVersion() {
      try {
        const res = await fetch('/api/version');
        const data = await res.json();
        const versionEl = document.getElementById('appVersion');
        if (versionEl) versionEl.textContent = `v${data.version}`;
      } catch (e) {
        console.error('Erreur chargement version:', e);
        const versionEl = document.getElementById('appVersion');
        if (versionEl) versionEl.textContent = 'v?.?.?';
      }
    })();
  </script>
</head>
<body>
  <header class="header">
    <button class="back-btn" onclick="window.location.href='/'">‚Üê</button>
    <div class="model-header">
      <div class="model-title" id="modelName">Chargement...</div>
      <span class="version" id="appVersion" style="margin-left: 1rem; font-size: 0.75rem; color: var(--text-secondary); background: rgba(99, 102, 241, 0.1); padding: 0.25rem 0.5rem; border-radius: 4px; border: 1px solid rgba(99, 102, 241, 0.2);">...</span>
      <div class="model-subtitle">
        <span class="status-dot" id="statusDot"></span>
        <span id="statusText">V√©rification...</span>
      </div>
    </div>
    <button class="action-btn" onclick="openSettingsModal()" style="background: rgba(99, 102, 241, 0.2); border: 1px solid rgba(99, 102, 241, 0.3);" title="Param√®tres">
      ‚öôÔ∏è Param√®tres
    </button>
    <div class="lang-selector" style="display: flex; gap: 0.5rem; margin-left: 1rem;">
      <button class="lang-btn" data-lang="fr" style="background: rgba(99, 102, 241, 0.1); color: var(--text-secondary); border: 1px solid var(--border); padding: 0.4rem 0.8rem; border-radius: 6px; cursor: pointer; font-size: 0.85rem; font-weight: 500; transition: all 0.2s;">üá´üá∑ FR</button>
      <button class="lang-btn" data-lang="en" style="background: rgba(99, 102, 241, 0.1); color: var(--text-secondary); border: 1px solid var(--border); padding: 0.4rem 0.8rem; border-radius: 6px; cursor: pointer; font-size: 0.85rem; font-weight: 500; transition: all 0.2s;">üá¨üáß EN</button>
    </div>
  </header>

  <div class="container">
    <!-- Onglets -->
    <div class="tabs">
      <button class="tab-btn active" onclick="switchTab('live')" data-i18n="live">üì∫ Live</button>
      <button class="tab-btn" onclick="switchTab('recordings')" data-i18n="replays">üìÅ Rediffusions</button>
    </div>

    <!-- Contenu Live -->
    <div id="tab-live" class="tab-content active">
      <div class="player-container">
        <video id="player" class="video-player" controls muted autoplay></video>
        <div class="quality-selector" id="qualitySelector" style="display: none;">
          <label for="qualitySelect">Qualit√© :</label>
          <select id="qualitySelect" onchange="changeQuality(this.value)">
            <option value="-1">üéØ Meilleure</option>
          </select>
        </div>
        <div class="empty-message">
          <div class="icon">üì∫</div>
          <p>Aucun stream en cours</p>
        </div>
      </div>
    </div>

    <!-- Contenu Rediffusions -->
    <div id="tab-recordings" class="tab-content">
      <div class="recordings-section">
        <div class="section-header">
          <span>üìÅ Enregistrements disponibles</span>
          <span class="recording-meta" id="recordingsCount">0 fichier</span>
        </div>
        <div class="recordings-list" id="recordingsList">
          <!-- Les enregistrements seront ajout√©s ici -->
        </div>
      </div>
    </div>
  </div>

  <!-- Modal Param√®tres -->
  <div class="modal" id="settingsModal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); z-index: 1000; align-items: center; justify-content: center;">
    <div class="modal-content" style="background: var(--bg-card); padding: 2rem; border-radius: 12px; max-width: 500px; width: 90%;">
      <h2 style="margin-bottom: 1.5rem; color: var(--text-primary);">‚öôÔ∏è Param√®tres du mod√®le</h2>
      <form onsubmit="saveSettings(event)">
        <div class="form-group" style="margin-bottom: 1.5rem;">
          <label for="settingsQuality" style="display: block; margin-bottom: 0.5rem; color: var(--text-primary); font-weight: 500;">Qualit√© d'enregistrement</label>
          <select id="settingsQuality" style="width: 100%; padding: 0.75rem; border: 1px solid var(--border); border-radius: 8px; background: var(--bg-secondary); color: var(--text-primary); font-size: 1rem;">
            <option value="best">üéØ Meilleure qualit√© (d√©faut)</option>
            <option value="1080p">1080p (Full HD)</option>
            <option value="720p">720p (HD)</option>
            <option value="480p">480p (SD)</option>
            <option value="360p">360p (Faible)</option>
          </select>
          <small style="color: var(--text-secondary); font-size: 0.875rem; margin-top: 0.25rem; display: block;">
            Qualit√© du flux enregistr√© (plus √©lev√© = plus d'espace disque)
          </small>
        </div>
        
        <div class="form-group" style="margin-bottom: 1.5rem;">
          <label for="settingsRetention" style="display: block; margin-bottom: 0.5rem; color: var(--text-primary); font-weight: 500;">Dur√©e de conservation (jours)</label>
          <input 
            type="number" 
            id="settingsRetention"
            min="1"
            max="365"
            style="width: 100%; padding: 0.75rem; border: 1px solid var(--border); border-radius: 8px; background: var(--bg-secondary); color: var(--text-primary); font-size: 1rem;"
            required
          />
          <small style="color: var(--text-secondary); font-size: 0.875rem; margin-top: 0.25rem; display: block;">
            Les rediffusions plus anciennes seront automatiquement supprim√©es (d√©faut: 30 jours)
          </small>
        </div>
        
        <div class="form-group" style="margin-bottom: 1.5rem;">
          <label style="display: flex; align-items: center; gap: 0.75rem; cursor: pointer; color: var(--text-primary); font-weight: 500;">
            <input 
              type="checkbox" 
              id="settingsAutoRecord"
              style="width: 20px; height: 20px; cursor: pointer; accent-color: var(--accent);"
            />
            <span>ü§ñ Enregistrement automatique</span>
          </label>
          <small style="color: var(--text-secondary); font-size: 0.875rem; margin-top: 0.5rem; display: block; margin-left: 2rem;">
            Le serveur enregistre automatiquement quand le mod√®le est en ligne (v√©rifi√© toutes les 2 minutes)
          </small>
        </div>
        
        <div style="display: flex; gap: 1rem; justify-content: flex-end; margin-top: 2rem;">
          <button type="button" onclick="closeSettingsModal()" style="padding: 0.75rem 1.5rem; border: 1px solid var(--border); border-radius: 8px; background: transparent; color: var(--text-primary); cursor: pointer; font-size: 1rem;">
            Annuler
          </button>
          <button type="submit" style="padding: 0.75rem 1.5rem; border: none; border-radius: 8px; background: var(--accent); color: white; cursor: pointer; font-size: 1rem; font-weight: 500;">
            üíæ Enregistrer
          </button>
        </div>
      </form>
      
      <hr style="margin: 2rem 0; border: none; border-top: 1px solid var(--border);" />
      
      <!-- Contr√¥les d'enregistrement manuel -->
      <div style="text-align: center; margin-bottom: 2rem;">
        <div style="margin-bottom: 1rem;">
          <strong style="color: var(--text-primary);">Contr√¥les manuels</strong>
          <div style="color: var(--text-secondary); font-size: 0.875rem; margin-top: 0.25rem;">
            D√©marrer ou arr√™ter l'enregistrement manuellement
          </div>
        </div>
        <button 
          type="button" 
          id="manualRecordBtn" 
          onclick="toggleRecording()" 
          style="padding: 0.75rem 1.5rem; border: 1px solid var(--accent); border-radius: 8px; background: rgba(99, 102, 241, 0.1); color: var(--accent); cursor: pointer; font-size: 1rem; font-weight: 500; transition: all 0.2s;">
          ‚è∫ D√©marrer l'enregistrement
        </button>
      </div>
      
      <hr style="margin: 2rem 0; border: none; border-top: 1px solid var(--border);" />
      
      <div style="text-align: center;">
        <button type="button" onclick="deleteModelFromSettings()" style="padding: 0.75rem 1.5rem; border: 1px solid var(--danger); border-radius: 8px; background: transparent; color: var(--danger); cursor: pointer; font-size: 1rem; font-weight: 500; transition: all 0.2s;">
          üóëÔ∏è Supprimer ce mod√®le
        </button>
        <div style="color: var(--text-secondary); font-size: 0.875rem; margin-top: 0.5rem;">
          Cette action est irr√©versible
        </div>
      </div>
    </div>
  </div>

  <script>
    const urlParams = new URLSearchParams(window.location.search);
    const username = urlParams.get('username');
    let currentSession = null;
    let hlsPlayer = null;

    if (!username) {
      window.location.href = '/';
    }

    // Initialisation
    document.getElementById('modelName').textContent = username;

    // R√©cup√©rer l'√©tat du mod√®le
    async function updateModelStatus() {
      try {
        // R√©cup√©rer les sessions actives
        const res = await fetch('/api/status');
        const sessions = await res.json();
        const session = sessions.find(s => s.person === username);

        // R√©cup√©rer le statut en ligne
        const statusRes = await fetch(`/api/model/${username}/status`);
        const modelInfo = statusRes.ok ? await statusRes.json() : { isOnline: false };

        if (session && session.running) {
          const wasRecording = currentSession && currentSession.id === session.id;
          currentSession = session;
          
          console.log('üìä Session trouv√©e:', session);
          console.log('üì∫ Playback URL:', session.playback_url);
          console.log('üîÑ √âtait d√©j√† en enregistrement:', wasRecording);
          
          document.getElementById('statusDot').className = 'status-dot recording';
          document.getElementById('statusText').textContent = 'En enregistrement';
          
          // Charger le stream UNIQUEMENT si ce n'√©tait pas d√©j√† en cours
          if (!wasRecording) {
            console.log('‚ñ∂Ô∏è Chargement du stream...');
            loadStream(session.playback_url);
          } else {
            console.log('‚è≠Ô∏è Stream d√©j√† charg√©, skip');
          }
        } else if (modelInfo.isOnline) {
          currentSession = null;
          document.getElementById('statusDot').className = 'status-dot online';
          document.getElementById('statusText').textContent = 'En ligne';
        } else {
          currentSession = null;
          document.getElementById('statusDot').className = 'status-dot offline';
          document.getElementById('statusText').textContent = 'Hors ligne';
        }
      } catch (e) {
        console.error('Erreur statut:', e);
      }
    }

    // Toggle enregistrement
    async function toggleRecording() {
      if (currentSession) {
        // Arr√™ter
        try {
          const res = await fetch(`/api/stop/${currentSession.id}`, { method: 'POST' });
          if (res.ok) {
            showNotification('Enregistrement arr√™t√©');
            await updateModelStatus();
            updateManualRecordButton();
          }
        } catch (e) {
          showNotification('Erreur lors de l\'arr√™t', 'error');
        }
      } else {
        // D√©marrer
        try {
          const res = await fetch('/api/start', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              target: username,
              source_type: 'chaturbate',
              person: username,
              name: username
            })
          });
          
          if (res.ok) {
            const data = await res.json();
            showNotification('Enregistrement d√©marr√©!');
            await updateModelStatus();
            updateManualRecordButton();
          } else if (res.status === 409) {
            // Session d√©j√† en cours, charger le stream quand m√™me
            console.log('‚è≠Ô∏è Session d√©j√† en cours, chargement du stream...');
            await updateModelStatus();
            updateManualRecordButton();
          } else {
            const error = await res.json();
            showNotification(error.detail || 'Erreur', 'error');
          }
        } catch (e) {
          showNotification('Erreur lors du d√©marrage', 'error');
        }
      }
    }

    // Charger le stream avec retry si le manifest n'est pas encore pr√™t
    async function loadStream(url) {
      console.log('üé¨ Chargement du stream:', url);
      const video = document.getElementById('player');
      
      // Attendre que le manifest soit disponible (max 10 tentatives)
      let retries = 10;
      while (retries > 0) {
        try {
          const checkResponse = await fetch(url, { method: 'HEAD' });
          if (checkResponse.ok) {
            console.log('‚úÖ Manifest disponible');
            break;
          }
        } catch (e) {
          console.log(`‚è≥ Manifest pas encore disponible, attente... (${retries} tentatives restantes)`);
        }
        retries--;
        if (retries > 0) {
          await new Promise(resolve => setTimeout(resolve, 1000)); // Attendre 1 seconde
        }
      }
      
      if (retries === 0) {
        console.error('‚ùå Manifest toujours indisponible apr√®s 10 secondes');
        showNotification('Stream non disponible, r√©essayez dans quelques secondes', 'error');
        return;
      }
      
      // Marquer le conteneur comme ayant une vid√©o
      const playerContainer = document.querySelector('.player-container');
      if (playerContainer) {
        playerContainer.classList.add('has-video');
      }
      
      if (video.canPlayType('application/vnd.apple.mpegurl')) {
        console.log('üì± Utilisation du lecteur natif');
        video.src = url;
        video.muted = true; // Son coup√©
        // D√©marrer automatiquement
        video.play().catch(e => {
          console.log('Autoplay bloqu√©');
          showNotification('Cliquez sur ‚ñ∂Ô∏è pour lancer', 'info');
        });
      } else if (window.Hls && window.Hls.isSupported()) {
        console.log('üé• Utilisation de HLS.js');
        if (hlsPlayer) {
          hlsPlayer.destroy();
        }
        hlsPlayer = new Hls({ 
          debug: false,
          enableWorker: false,
          capLevelToPlayerSize: false,  // Ne pas limiter la qualit√© √† la taille du lecteur
        });
        
        // Gestion des erreurs HLS
        hlsPlayer.on(Hls.Events.ERROR, (event, data) => {
          console.error('‚ùå Erreur HLS:', data);
          console.error('Type:', data.type, 'Fatal:', data.fatal, 'Details:', data.details);
          
          // Afficher l'erreur √† l'utilisateur
          const errorMsg = `Erreur HLS: ${data.details} (${data.type})`;
          showNotification(errorMsg, 'error');
          
          if (data.fatal) {
            switch(data.type) {
              case Hls.ErrorTypes.NETWORK_ERROR:
                console.log('üîÑ Erreur r√©seau, tentative de r√©cup√©ration...');
                showNotification('Erreur r√©seau, reconnexion...', 'info');
                hlsPlayer.startLoad();
                break;
              case Hls.ErrorTypes.MEDIA_ERROR:
                console.log('üîÑ Erreur m√©dia, tentative de r√©cup√©ration...');
                showNotification('Erreur m√©dia, r√©cup√©ration...', 'info');
                hlsPlayer.recoverMediaError();
                break;
              default:
                console.error('üí• Erreur fatale, rechargement...');
                showNotification('Erreur fatale, rechargement dans 2s...', 'error');
                hlsPlayer.destroy();
                setTimeout(() => loadStream(url), 2000);
                break;
            }
          }
        });
        
        hlsPlayer.loadSource(url);
        hlsPlayer.attachMedia(video);
        
        hlsPlayer.on(Hls.Events.MANIFEST_PARSED, () => {
          console.log('‚úÖ Manifest charg√©, d√©marrage lecture...');
          
          // FORCER LA MEILLEURE QUALIT√â IMM√âDIATEMENT
          if (hlsPlayer.levels.length > 0) {
            const highestLevel = hlsPlayer.levels.length - 1;
            hlsPlayer.currentLevel = highestLevel;  // Forcer imm√©diatement
            hlsPlayer.loadLevel = highestLevel;  // Forcer le chargement
            hlsPlayer.autoLevelCapping = highestLevel;  // Limiter le plafond
            hlsPlayer.startLevel = highestLevel;  // D√©marrer au max
            console.log(`üéöÔ∏è Meilleure qualit√© forc√©e: ${hlsPlayer.levels[highestLevel].height}p`);
            showNotification(`Qualit√©: ${hlsPlayer.levels[highestLevel].height}p (Max)`, 'success');
          }
          
          // Afficher le s√©lecteur de qualit√© si plusieurs niveaux disponibles
          if (hlsPlayer.levels.length > 1) {
            updateQualitySelector();
          }
          
          // Son coup√© pour autoplay
          video.muted = true;
          // D√©marrer automatiquement
          video.play().then(() => {
            console.log('‚úÖ Lecture d√©marr√©e (son coup√©)');
            showNotification('Lecture d√©marr√©e (cliquez üîä pour activer le son)', 'info');
          }).catch(e => {
            console.log('Autoplay bloqu√©');
            showNotification('Cliquez sur ‚ñ∂Ô∏è pour lancer', 'info');
          });
        });
        
        hlsPlayer.on(Hls.Events.LEVEL_LOADED, (event, data) => {
          console.log('‚úÖ Niveau charg√©:', data.level, 'Segments:', data.details.fragments.length);
        });
        
        hlsPlayer.on(Hls.Events.LEVEL_SWITCHED, (event, data) => {
          console.log('üéöÔ∏è Qualit√© chang√©e:', data.level);
          updateQualitySelector();
        });
        
      } else {
        console.error('HLS non support√© par ce navigateur');
        showNotification('HLS non support√©', 'error');
      }
    }

    // Mettre √† jour le s√©lecteur de qualit√©
    function updateQualitySelector() {
      if (!hlsPlayer || hlsPlayer.levels.length <= 1) {
        document.getElementById('qualitySelector').style.display = 'none';
        return;
      }
      
      const selector = document.getElementById('qualitySelector');
      const select = document.getElementById('qualitySelect');
      
      // Vider les options
      select.innerHTML = '<option value="-1">üéØ Meilleure</option>';
      
      // Ajouter toutes les qualit√©s disponibles
      hlsPlayer.levels.forEach((level, index) => {
        const height = level.height;
        const bitrate = Math.round(level.bitrate / 1000);
        const label = height ? `${height}p (${bitrate} kbps)` : `${bitrate} kbps`;
        
        const option = document.createElement('option');
        option.value = index;
        option.textContent = label;
        
        if (hlsPlayer.currentLevel === index) {
          option.selected = true;
        }
        
        select.appendChild(option);
      });
      
      // Afficher le s√©lecteur
      selector.style.display = 'flex';
      
      console.log(`üéöÔ∏è ${hlsPlayer.levels.length} qualit√©s disponibles`);
    }
    
    // Changer la qualit√©
    function changeQuality(levelIndex) {
      if (!hlsPlayer) return;
      
      const level = parseInt(levelIndex);
      
      if (level === -1) {
        // Mode Auto = Forcer la meilleure qualit√© disponible
        const highestLevel = hlsPlayer.levels.length - 1;
        hlsPlayer.loadLevel = highestLevel;
        hlsPlayer.autoLevelCapping = highestLevel;
        const bestLevel = hlsPlayer.levels[highestLevel];
        const label = bestLevel.height ? `${bestLevel.height}p` : `${Math.round(bestLevel.bitrate / 1000)} kbps`;
        console.log(`üéöÔ∏è Mode Auto: Meilleure qualit√© forc√©e (${label})`);
        showNotification(`Qualit√©: Meilleure (${label})`, 'info');
      } else {
        hlsPlayer.currentLevel = level;
        const selectedLevel = hlsPlayer.levels[level];
        const label = selectedLevel.height ? `${selectedLevel.height}p` : `${Math.round(selectedLevel.bitrate / 1000)} kbps`;
        console.log(`üéöÔ∏è Qualit√© s√©lectionn√©e: ${label}`);
        showNotification(`Qualit√©: ${label}`, 'info');
      }
    }

    // Charger les enregistrements
    async function loadRecordings() {
      const list = document.getElementById('recordingsList');
      const count = document.getElementById('recordingsCount');
      
      try {
        const res = await fetch(`/api/recordings/${username}`);
        const data = await res.json();
        
        // Filtrer les enregistrements: NE PAS afficher celui en cours (aujourd'hui)
        const today = new Date().toISOString().split('T')[0]; // Format YYYY-MM-DD
        const recordings = (data.recordings || []).filter(rec => {
          // Si un enregistrement est en cours pour aujourd'hui, on ne l'affiche pas
          if (currentSession && currentSession.running && rec.date === today) {
            return false;
          }
          return true;
        });
        
        if (recordings.length > 0) {
          count.textContent = `${recordings.length} fichier${recordings.length > 1 ? 's' : ''}`;
          
          list.innerHTML = recordings.map(rec => {
            const progress = getWatchProgress(rec.filename);
            const progressPercent = progress ? Math.round((progress.position / progress.duration) * 100) : 0;
            
            // Formater le temps de progression
            let progressTimeStr = '';
            if (progress && progress.position > 0) {
              const pos = Math.floor(progress.position);
              const dur = Math.floor(progress.duration);
              
              const formatTime = (seconds) => {
                const h = Math.floor(seconds / 3600);
                const m = Math.floor((seconds % 3600) / 60);
                const s = seconds % 60;
                if (h > 0) return `${h}h${m.toString().padStart(2, '0')}m`;
                return `${m}m${s.toString().padStart(2, '0')}s`;
              };
              
              progressTimeStr = `${formatTime(pos)} / ${formatTime(dur)}`;
            }
            
            return `
            <div class="recording-item">
              <img 
                src="${rec.thumbnail || '/api/recording-thumbnail/' + username + '/' + rec.date + '.jpg'}" 
                alt="${rec.date}"
                class="recording-thumbnail"
                onerror="this.src='data:image/svg+xml,%3Csvg xmlns=%22http://www.w3.org/2000/svg%22 width=%22160%22 height=%2290%22%3E%3Crect fill=%22%231a1f3a%22 width=%22160%22 height=%2290%22/%3E%3Ctext x=%2250%25%22 y=%2250%25%22 dominant-baseline=%22middle%22 text-anchor=%22middle%22 fill=%22%23a0aec0%22 font-size=%2214%22%3Eüìπ%3C/text%3E%3C/svg%3E'"
                onclick="playRecording('${rec.url}', '${rec.filename}')"
              />
              <div class="recording-info" onclick="playRecording('${rec.url}', '${rec.filename}')">
                <div class="recording-title">üìπ ${rec.date}</div>
                <div class="recording-meta">
                  ${rec.duration_str || ''} ${rec.duration_str ? '¬∑' : ''} ${rec.size_mb} MB
                </div>
                ${progressPercent > 0 ? `
                  <div class="watch-progress">
                    <div class="progress-bar">
                      <div class="progress-fill" style="width: ${progressPercent}%"></div>
                    </div>
                    <span class="progress-text">${progressTimeStr}</span>
                  </div>
                ` : ''}
              </div>
              <div class="recording-actions">
                <button class="play-btn" onclick="event.stopPropagation(); playRecording('${rec.url}', '${rec.filename}')">‚ñ∂Ô∏è</button>
                <button class="delete-btn" onclick="event.stopPropagation(); deleteRecording('${rec.filename}')">üóëÔ∏è</button>
              </div>
            </div>
          `;
          }).join('');
        } else {
          list.innerHTML = `
            <div class="empty-message">
              <div class="icon">üìÇ</div>
              <p>Aucun enregistrement disponible</p>
              <p style="font-size: 0.85rem; margin-top: 0.5rem; opacity: 0.7;">Les enregistrements appara√Ætront ici</p>
            </div>
          `;
          count.textContent = '0 fichier';
        }
      } catch (e) {
        console.error('Erreur chargement enregistrements:', e);
        list.innerHTML = `
          <div class="empty-message">
            <div class="icon">‚ö†Ô∏è</div>
            <p>Erreur de chargement</p>
          </div>
        `;
      }
    }
    
    // Sauvegarder la progression de lecture
    function saveWatchProgress(filename, position, duration) {
      const key = `watch_progress_${username}_${filename}`;
      localStorage.setItem(key, JSON.stringify({ position, duration, timestamp: Date.now() }));
    }
    
    // R√©cup√©rer la progression de lecture
    function getWatchProgress(filename) {
      const key = `watch_progress_${username}_${filename}`;
      const data = localStorage.getItem(key);
      return data ? JSON.parse(data) : null;
    }
    
    // Variable pour suivre l'enregistrement en cours
    let currentRecordingFile = null;
    
    // Lire un enregistrement
    function playRecording(url, filename) {
      console.log('üìπ Lecture enregistrement:', url);
      
      // S√âCURIT√â: Emp√™cher la lecture de l'enregistrement du jour en cours
      const today = new Date().toISOString().split('T')[0];
      const recordingDate = filename.replace('.ts', '');
      
      if (currentSession && currentSession.running && recordingDate === today) {
        showNotification('‚ö†Ô∏è Enregistrement en cours ! Regardez le live au lieu de la rediffusion.', 'error');
        switchTab('live');
        return;
      }
      
      const video = document.getElementById('player');
      const container = document.querySelector('.player-container');
      
      // Arr√™ter le lecteur HLS si actif
      if (hlsPlayer) {
        hlsPlayer.destroy();
        hlsPlayer = null;
      }
      
      // Masquer le s√©lecteur de qualit√© (pas de HLS pour les rediffusions)
      document.getElementById('qualitySelector').style.display = 'none';
      
      currentRecordingFile = filename;
      
      // Afficher le conteneur vid√©o
      container.classList.add('has-video');
      
      // Charger la vid√©o directement
      video.src = url;
      video.load();  // Force le chargement
      
      // Reprendre √† la position sauvegard√©e
      const progress = getWatchProgress(filename);
      if (progress && progress.position > 10) {
        video.addEventListener('loadedmetadata', () => {
          video.currentTime = progress.position;
          showNotification(`Reprise √† ${Math.floor(progress.position / 60)}min ${Math.floor(progress.position % 60)}s`, 'info');
        }, { once: true });
      }
      
      // D√©marrer la lecture
      video.play().catch(e => {
        console.error('Erreur lecture:', e);
        showNotification('Cliquez sur ‚ñ∂Ô∏è pour lancer la lecture', 'info');
      });
      
      // Retourner √† l'onglet Live pour voir le lecteur
      switchTab('live');
      
      showNotification('Chargement de la rediffusion...', 'info');
    }
    
    // Supprimer un enregistrement
    async function deleteRecording(filename) {
      if (!confirm(`Supprimer ${filename.replace('.ts', '')} ?\n\nCette action est irr√©versible.`)) {
        return;
      }
      
      try {
        const res = await fetch(`/api/recordings/${username}/${filename}`, {
          method: 'DELETE'
        });
        
        if (res.ok) {
          showNotification('Enregistrement supprim√©', 'info');
          // Supprimer aussi la progression
          const key = `watch_progress_${username}_${filename}`;
          localStorage.removeItem(key);
          // Recharger la liste
          loadRecordings();
        } else {
          showNotification('Erreur lors de la suppression', 'error');
        }
      } catch (e) {
        console.error('Erreur suppression:', e);
        showNotification('Erreur lors de la suppression', 'error');
      }
    }

    // Param√®tres du mod√®le
    async function openSettingsModal() {
      // Charger les param√®tres actuels du mod√®le
      try {
        const res = await fetch('/api/models');
        if (res.ok) {
          const data = await res.json();
          const model = data.models.find(m => m.username === username);
          
          if (model) {
            document.getElementById('settingsQuality').value = model.recordQuality || 'best';
            document.getElementById('settingsRetention').value = model.retentionDays || 30;
            document.getElementById('settingsAutoRecord').checked = model.autoRecord !== false; // Par d√©faut true
          } else {
            // Valeurs par d√©faut si le mod√®le n'existe pas
            document.getElementById('settingsQuality').value = 'best';
            document.getElementById('settingsRetention').value = 30;
            document.getElementById('settingsAutoRecord').checked = true;
          }
        }
      } catch (e) {
        console.error('Erreur chargement param√®tres:', e);
      }
      
      // Mettre √† jour le bouton d'enregistrement manuel
      updateManualRecordButton();
      
      // Afficher le modal
      document.getElementById('settingsModal').style.display = 'flex';
    }
    
    // Mettre √† jour le bouton d'enregistrement manuel
    function updateManualRecordButton() {
      const btn = document.getElementById('manualRecordBtn');
      if (!btn) return;
      
      if (currentSession && currentSession.running) {
        btn.innerHTML = '‚èπÔ∏è Arr√™ter l\'enregistrement';
        btn.style.borderColor = 'var(--danger)';
        btn.style.color = 'var(--danger)';
        btn.style.background = 'rgba(239, 68, 68, 0.1)';
      } else {
        btn.innerHTML = '‚è∫ D√©marrer l\'enregistrement';
        btn.style.borderColor = 'var(--accent)';
        btn.style.color = 'var(--accent)';
        btn.style.background = 'rgba(99, 102, 241, 0.1)';
      }
    }
    
    function closeSettingsModal() {
      document.getElementById('settingsModal').style.display = 'none';
    }
    
    async function saveSettings(event) {
      event.preventDefault();
      
      const quality = document.getElementById('settingsQuality').value;
      const retention = parseInt(document.getElementById('settingsRetention').value);
      const autoRecord = document.getElementById('settingsAutoRecord').checked;
      
      try {
        const res = await fetch(`/api/models/${username}`, {
          method: 'PUT',
          headers: {
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({
            recordQuality: quality,
            retentionDays: retention,
            autoRecord: autoRecord
          })
        });
        
        if (res.ok) {
          showNotification('Param√®tres sauvegard√©s', 'success');
          closeSettingsModal();
        } else {
          showNotification('Erreur lors de la sauvegarde', 'error');
        }
      } catch (e) {
        console.error('Erreur sauvegarde param√®tres:', e);
        showNotification('Erreur de connexion', 'error');
      }
    }
    
    // Supprimer le mod√®le depuis les param√®tres
    async function deleteModelFromSettings() {
      if (!confirm(`Voulez-vous vraiment supprimer ${username} de votre liste ?\n\nCette action est irr√©versible.`)) {
        return;
      }
      
      try {
        const res = await fetch(`/api/models/${username}`, {
          method: 'DELETE'
        });
        
        if (res.ok) {
          showNotification('Mod√®le supprim√©');
          setTimeout(() => window.location.href = '/', 1000);
        } else {
          showNotification('Erreur lors de la suppression', 'error');
        }
      } catch (e) {
        console.error('Erreur suppression mod√®le:', e);
        showNotification('Erreur de connexion', 'error');
      }
    }

    // Switch entre onglets
    function switchTab(tabName) {
      // G√©rer les boutons
      document.querySelectorAll('.tab-btn').forEach(btn => btn.classList.remove('active'));
      event.target.classList.add('active');
      
      // G√©rer le contenu
      document.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));
      document.getElementById(`tab-${tabName}`).classList.add('active');
      
      // Si onglet recordings, charger la liste
      if (tabName === 'recordings') {
        loadRecordings();
      }
    }

    // Supprimer le mod√®le
    async function deleteModel() {
      if (!confirm(`Voulez-vous vraiment supprimer ${username} de votre liste ?`)) {
        return;
      }
      
      try {
        const res = await fetch(`/api/models/${username}`, {
          method: 'DELETE'
        });
        
        if (res.ok) {
          showNotification('Mod√®le supprim√©');
          setTimeout(() => window.location.href = '/', 1000);
        } else {
          showNotification('Erreur lors de la suppression', 'error');
        }
      } catch (e) {
        console.error('Erreur suppression mod√®le:', e);
        showNotification('Erreur de connexion', 'error');
      }
    }

    // Notification
    function showNotification(message, type = 'success') {
      const notif = document.createElement('div');
      const bgColor = type === 'success' ? '#10b981' : '#ef4444';
      notif.style.cssText = `
        position: fixed;
        top: 20px;
        right: 20px;
        background: ${bgColor};
        color: white;
        padding: 1rem 1.5rem;
        border-radius: 10px;
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
        z-index: 9999;
        font-weight: 500;
      `;
      notif.textContent = message;
      document.body.appendChild(notif);
      setTimeout(() => notif.remove(), 3000);
    }

    // D√©marrage automatique de l'enregistrement si en ligne
    async function autoStartRecording() {
      try {
        const statusRes = await fetch(`/api/model/${username}/status`);
        if (!statusRes.ok) return;
        
        const modelInfo = await statusRes.json();
        
        // Si le mod√®le est en ligne
        if (modelInfo.isOnline) {
          // V√©rifier s'il n'y a pas d√©j√† une session
          const sessionsRes = await fetch('/api/status');
          const sessions = await sessionsRes.json();
          const existingSession = sessions.find(s => s.person === username && s.running);
          
          // Si pas de session, d√©marrer automatiquement
          if (!existingSession) {
            console.log(`üé¨ D√©marrage automatique de l'enregistrement pour ${username}`);
            await toggleRecording();
          } else {
            console.log(`‚è≠Ô∏è Session d√©j√† en cours pour ${username}, chargement du stream...`);
            // La session existe d√©j√†, on va juste charger le stream
            await updateModelStatus();
          }
        }
      } catch (e) {
        console.error('Erreur auto-start:', e);
      }
    }

    // Sauvegarder la progression toutes les 10 secondes
    const video = document.getElementById('player');
    setInterval(() => {
      if (currentRecordingFile && video.currentTime > 0 && video.duration > 0) {
        saveWatchProgress(currentRecordingFile, video.currentTime, video.duration);
      }
    }, 10000);
    
    // Sauvegarder aussi √† la pause ou en quittant la page
    video.addEventListener('pause', () => {
      if (currentRecordingFile && video.currentTime > 0 && video.duration > 0) {
        saveWatchProgress(currentRecordingFile, video.currentTime, video.duration);
      }
    });
    
    window.addEventListener('beforeunload', () => {
      if (currentRecordingFile && video.currentTime > 0 && video.duration > 0) {
        saveWatchProgress(currentRecordingFile, video.currentTime, video.duration);
      }
    });

    // Initialisation
    updateModelStatus();
    loadRecordings();
    
    // D√©marrer automatiquement l'enregistrement apr√®s un court d√©lai
    setTimeout(autoStartRecording, 2000);
    
    // Rafra√Æchir toutes les 10 secondes (moins agressif)
    setInterval(updateModelStatus, 10000);
  </script>
</body>
</html>
